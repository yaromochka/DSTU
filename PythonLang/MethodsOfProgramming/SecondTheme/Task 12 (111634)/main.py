"""
Задача №111634. Робот

Студенты одного из вузов спроектировали робота для частичной автоматизации процесса сборки авиационного двигателя.

В процессе сборки двигателя могут встречаться операции 26 типов, которые обозначаются строчными буквами латинского алфавита.
Процесс сборки состоит из N операций.

Предполагается использовать робота один раз для выполнения части подряд идущих операций из процесса сборки.

Память робота состоит из K ячеек, каждая из которых содержит одну операцию.
Операции выполняются последовательно, начиная с первой, в том порядке, в котором они расположены в памяти.
Выполнив последнюю из них, робот продолжает работу с первой. Робота можно остановить после любой операции.
Использование робота экономически целесообразно, если он выполнит хотя бы K+1 операцию.

Требуется написать программу, которая по заданному процессу сборки определит количество экономически целесообразных
способов использования робота.

Входные данные

В первой строке входного файла записано число K>0 "— количество операций, которые можно записать в память робота.

Вторая строка состоит из N>K строчных латинских букв, обозначающих операции "— процесс сборки двигателя.
Операции одного и того же типа обозначаются одной и той же буквой.

Выходные данные

Выходной файл должен содержать единственное целое число "— количество экономически целесообразных способов использования робота.
"""


def count_economically_viable_ways(k: int, operations: str) -> int:
    """
    Подсчитывает количество экономически целесообразных способов использования робота.
    :param k: Количество операций, которые можно записать в память робота.
    :param operations: Операции для сборки двигателя.
    :returns: Количество экономически целесообразных способов использования робота.
    """
    n: int = len(operations)
    viable_ways: int = 0
    consecutive_matches: int = 0

    # Проходим по строке операций с конца к началу
    for i in range(n - k - 1, -1, -1):
        if operations[i] == operations[i + k]:
            consecutive_matches += 1
        else:
            consecutive_matches = 0

        viable_ways += consecutive_matches

    return viable_ways


def main() -> None:
    k: int = int(input())
    operations: str = input()

    result: int = count_economically_viable_ways(k, operations)
    print(result)


if __name__ == "__main__":
    main()